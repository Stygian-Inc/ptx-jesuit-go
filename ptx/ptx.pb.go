// PTX: The Portable Trust eXtensible file format
// Version: 1.0
//
// This schema defines the structure for a PTX file, a self-contained,
// non-interactive proof container designed for verifiable claims.
//
// A valid PTX file is a binary file composed of two parts:
// 1. A 4-byte magic header: "PTX\x01" (Hex: 50 54 58 01)
// 2. The serialized Protobuf message for the PtxFile defined below.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.2
// source: ptx.proto

package ptx

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// TrustMethod defines the public, auditable system used to anchor the commitment.
type TrustMethod int32

const (
	TrustMethod_METHOD_UNSPECIFIED TrustMethod = 0 // Invalid, must be explicitly set.
	TrustMethod_DOH                TrustMethod = 1 // DNS TXT Record method via Domain of Interest.
	TrustMethod_GIST               TrustMethod = 2 // GitHub Gist method.
)

// Enum value maps for TrustMethod.
var (
	TrustMethod_name = map[int32]string{
		0: "METHOD_UNSPECIFIED",
		1: "DOH",
		2: "GIST",
	}
	TrustMethod_value = map[string]int32{
		"METHOD_UNSPECIFIED": 0,
		"DOH":                1,
		"GIST":               2,
	}
)

func (x TrustMethod) Enum() *TrustMethod {
	p := new(TrustMethod)
	*p = x
	return p
}

func (x TrustMethod) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TrustMethod) Descriptor() protoreflect.EnumDescriptor {
	return file_ptx_proto_enumTypes[0].Descriptor()
}

func (TrustMethod) Type() protoreflect.EnumType {
	return &file_ptx_proto_enumTypes[0]
}

func (x TrustMethod) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TrustMethod.Descriptor instead.
func (TrustMethod) EnumDescriptor() ([]byte, []int) {
	return file_ptx_proto_rawDescGZIP(), []int{0}
}

// ProofSystem defines the supported zero-knowledge proof systems.
type ProofSystem int32

const (
	ProofSystem_SYSTEM_UNSPECIFIED ProofSystem = 0 // Invalid, must be explicitly set.
	ProofSystem_GROTH16            ProofSystem = 1
	ProofSystem_PLONK              ProofSystem = 2
	ProofSystem_STARK              ProofSystem = 3 // Example for future extensibility.
)

// Enum value maps for ProofSystem.
var (
	ProofSystem_name = map[int32]string{
		0: "SYSTEM_UNSPECIFIED",
		1: "GROTH16",
		2: "PLONK",
		3: "STARK",
	}
	ProofSystem_value = map[string]int32{
		"SYSTEM_UNSPECIFIED": 0,
		"GROTH16":            1,
		"PLONK":              2,
		"STARK":              3,
	}
)

func (x ProofSystem) Enum() *ProofSystem {
	p := new(ProofSystem)
	*p = x
	return p
}

func (x ProofSystem) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProofSystem) Descriptor() protoreflect.EnumDescriptor {
	return file_ptx_proto_enumTypes[1].Descriptor()
}

func (ProofSystem) Type() protoreflect.EnumType {
	return &file_ptx_proto_enumTypes[1]
}

func (x ProofSystem) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProofSystem.Descriptor instead.
func (ProofSystem) EnumDescriptor() ([]byte, []int) {
	return file_ptx_proto_rawDescGZIP(), []int{1}
}

// PtxFile is the root message of the entire file format. It encapsulates
// the cryptographic proof, the human-readable metadata, the anchor details,
// and an optional institutional signature for platform attestation.
type PtxFile struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The trust method used to anchor this proof. This determines which field in
	// the 'anchor' oneof should be populated and how a verifier should locate
	// the public commitment.
	TrustMethod TrustMethod `protobuf:"varint,1,opt,name=trust_method,json=trustMethod,proto3,enum=ptx.v1.TrustMethod" json:"trust_method,omitempty"`
	// The core zero-knowledge proof and its system-specific parameters.
	Proof *ZkProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
	// The signed metadata payload, which represents the "claim" that the proof
	// attests to. It is RECOMMENDED that this field contain a JWS (JSON Web
	// Signature) compact serialization string. The JWS payload should contain
	// the rich context, including the 'entities' and security-critical 'purpose' objects.
	SignedMetadata string `protobuf:"bytes,3,opt,name=signed_metadata,json=signedMetadata,proto3" json:"signed_metadata,omitempty"`
	// The anchor contains the details needed to locate the public commitment.
	// The specific message used here MUST correspond to the 'trust_method'.
	//
	// Types that are valid to be assigned to Anchor:
	//
	//	*PtxFile_DohDetails
	//	*PtxFile_GistDetails
	Anchor isPtxFile_Anchor `protobuf_oneof:"anchor"`
	// OPTIONAL: A signature made by a trusted platform or institution.
	// This provides a powerful layer of provenance, attesting that the platform
	// has successfully verified the inner proof. It is used by end-verifiers
	// (e.g., a university) to trust that the proof originated from a known
	// intermediary (e.g., Common App).
	IssuerSignature *IssuerSignature `protobuf:"bytes,6,opt,name=issuer_signature,json=issuerSignature,proto3" json:"issuer_signature,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PtxFile) Reset() {
	*x = PtxFile{}
	mi := &file_ptx_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PtxFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PtxFile) ProtoMessage() {}

func (x *PtxFile) ProtoReflect() protoreflect.Message {
	mi := &file_ptx_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PtxFile.ProtoReflect.Descriptor instead.
func (*PtxFile) Descriptor() ([]byte, []int) {
	return file_ptx_proto_rawDescGZIP(), []int{0}
}

func (x *PtxFile) GetTrustMethod() TrustMethod {
	if x != nil {
		return x.TrustMethod
	}
	return TrustMethod_METHOD_UNSPECIFIED
}

func (x *PtxFile) GetProof() *ZkProof {
	if x != nil {
		return x.Proof
	}
	return nil
}

func (x *PtxFile) GetSignedMetadata() string {
	if x != nil {
		return x.SignedMetadata
	}
	return ""
}

func (x *PtxFile) GetAnchor() isPtxFile_Anchor {
	if x != nil {
		return x.Anchor
	}
	return nil
}

func (x *PtxFile) GetDohDetails() *DohAnchor {
	if x != nil {
		if x, ok := x.Anchor.(*PtxFile_DohDetails); ok {
			return x.DohDetails
		}
	}
	return nil
}

func (x *PtxFile) GetGistDetails() *GistAnchor {
	if x != nil {
		if x, ok := x.Anchor.(*PtxFile_GistDetails); ok {
			return x.GistDetails
		}
	}
	return nil
}

func (x *PtxFile) GetIssuerSignature() *IssuerSignature {
	if x != nil {
		return x.IssuerSignature
	}
	return nil
}

type isPtxFile_Anchor interface {
	isPtxFile_Anchor()
}

type PtxFile_DohDetails struct {
	DohDetails *DohAnchor `protobuf:"bytes,4,opt,name=doh_details,json=dohDetails,proto3,oneof"`
}

type PtxFile_GistDetails struct {
	GistDetails *GistAnchor `protobuf:"bytes,5,opt,name=gist_details,json=gistDetails,proto3,oneof"` // Future anchor methods can be added here without breaking compatibility.
}

func (*PtxFile_DohDetails) isPtxFile_Anchor() {}

func (*PtxFile_GistDetails) isPtxFile_Anchor() {}

// ZkProof encapsulates the proof data and the necessary context for verification.
type ZkProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The underlying ZKP system used to generate this proof. The verifier MUST
	// use this to select the correct verification algorithm.
	ProofSystem ProofSystem `protobuf:"varint,1,opt,name=proof_system,json=proofSystem,proto3,enum=ptx.v1.ProofSystem" json:"proof_system,omitempty"`
	// An identifier for the verification key (and its associated circuit).
	// This could be a hash of the VK, a URL, or a versioned name (e.g.,
	// "doh-v1.0-main"). The verifier uses this to fetch or select the correct
	// verification key for the specified proof_system.
	VerificationKeyId string `protobuf:"bytes,2,opt,name=verification_key_id,json=verificationKeyId,proto3" json:"verification_key_id,omitempty"`
	// The raw proof data, serialized according to the specified proof_system.
	ProofData     []byte `protobuf:"bytes,3,opt,name=proof_data,json=proofData,proto3" json:"proof_data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ZkProof) Reset() {
	*x = ZkProof{}
	mi := &file_ptx_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZkProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZkProof) ProtoMessage() {}

func (x *ZkProof) ProtoReflect() protoreflect.Message {
	mi := &file_ptx_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZkProof.ProtoReflect.Descriptor instead.
func (*ZkProof) Descriptor() ([]byte, []int) {
	return file_ptx_proto_rawDescGZIP(), []int{1}
}

func (x *ZkProof) GetProofSystem() ProofSystem {
	if x != nil {
		return x.ProofSystem
	}
	return ProofSystem_SYSTEM_UNSPECIFIED
}

func (x *ZkProof) GetVerificationKeyId() string {
	if x != nil {
		return x.VerificationKeyId
	}
	return ""
}

func (x *ZkProof) GetProofData() []byte {
	if x != nil {
		return x.ProofData
	}
	return nil
}

// IssuerSignature encapsulates an X.509 signature and the certificate chain
// needed to verify it, leveraging the existing WebPKI trust infrastructure.
type IssuerSignature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An identifier for the signature algorithm used, corresponding to standards
	// recognized by X.509, e.g., "SHA256withRSA".
	SignatureAlgorithm string `protobuf:"bytes,1,opt,name=signature_algorithm,json=signatureAlgorithm,proto3" json:"signature_algorithm,omitempty"`
	// The raw signature bytes. This signature is calculated over the entire
	// serialized PtxFile message, with this 'issuer_signature' field itself
	// being empty during the calculation to create a canonical payload.
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// The chain of X.509 certificates required to verify the signature.
	// The first certificate MUST be the leaf certificate whose private key
	// created the signature. Each subsequent certificate certifies the one
	// preceding it. Certificates should be in the binary DER format.
	CertificateChain [][]byte `protobuf:"bytes,3,rep,name=certificate_chain,json=certificateChain,proto3" json:"certificate_chain,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *IssuerSignature) Reset() {
	*x = IssuerSignature{}
	mi := &file_ptx_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssuerSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssuerSignature) ProtoMessage() {}

func (x *IssuerSignature) ProtoReflect() protoreflect.Message {
	mi := &file_ptx_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssuerSignature.ProtoReflect.Descriptor instead.
func (*IssuerSignature) Descriptor() ([]byte, []int) {
	return file_ptx_proto_rawDescGZIP(), []int{2}
}

func (x *IssuerSignature) GetSignatureAlgorithm() string {
	if x != nil {
		return x.SignatureAlgorithm
	}
	return ""
}

func (x *IssuerSignature) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *IssuerSignature) GetCertificateChain() [][]byte {
	if x != nil {
		return x.CertificateChain
	}
	return nil
}

// DohAnchor contains the details required for the DoH (DNS) trust method.
type DohAnchor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The fully qualified domain name that anchors the proof, e.g., "example.com".
	DomainName    string `protobuf:"bytes,1,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DohAnchor) Reset() {
	*x = DohAnchor{}
	mi := &file_ptx_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DohAnchor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DohAnchor) ProtoMessage() {}

func (x *DohAnchor) ProtoReflect() protoreflect.Message {
	mi := &file_ptx_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DohAnchor.ProtoReflect.Descriptor instead.
func (*DohAnchor) Descriptor() ([]byte, []int) {
	return file_ptx_proto_rawDescGZIP(), []int{3}
}

func (x *DohAnchor) GetDomainName() string {
	if x != nil {
		return x.DomainName
	}
	return ""
}

// GistAnchor contains the details required for the GIST (GitHub Gist) trust method.
type GistAnchor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The full URL of the public gist, e.g., "https://gist.github.com/user/id".
	GistUrl       string `protobuf:"bytes,1,opt,name=gist_url,json=gistUrl,proto3" json:"gist_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GistAnchor) Reset() {
	*x = GistAnchor{}
	mi := &file_ptx_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GistAnchor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GistAnchor) ProtoMessage() {}

func (x *GistAnchor) ProtoReflect() protoreflect.Message {
	mi := &file_ptx_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GistAnchor.ProtoReflect.Descriptor instead.
func (*GistAnchor) Descriptor() ([]byte, []int) {
	return file_ptx_proto_rawDescGZIP(), []int{4}
}

func (x *GistAnchor) GetGistUrl() string {
	if x != nil {
		return x.GistUrl
	}
	return ""
}

var File_ptx_proto protoreflect.FileDescriptor

const file_ptx_proto_rawDesc = "" +
	"\n" +
	"\tptx.proto\x12\x06ptx.v1\"\xce\x02\n" +
	"\aPtxFile\x126\n" +
	"\ftrust_method\x18\x01 \x01(\x0e2\x13.ptx.v1.TrustMethodR\vtrustMethod\x12%\n" +
	"\x05proof\x18\x02 \x01(\v2\x0f.ptx.v1.ZkProofR\x05proof\x12'\n" +
	"\x0fsigned_metadata\x18\x03 \x01(\tR\x0esignedMetadata\x124\n" +
	"\vdoh_details\x18\x04 \x01(\v2\x11.ptx.v1.DohAnchorH\x00R\n" +
	"dohDetails\x127\n" +
	"\fgist_details\x18\x05 \x01(\v2\x12.ptx.v1.GistAnchorH\x00R\vgistDetails\x12B\n" +
	"\x10issuer_signature\x18\x06 \x01(\v2\x17.ptx.v1.IssuerSignatureR\x0fissuerSignatureB\b\n" +
	"\x06anchor\"\x90\x01\n" +
	"\aZkProof\x126\n" +
	"\fproof_system\x18\x01 \x01(\x0e2\x13.ptx.v1.ProofSystemR\vproofSystem\x12.\n" +
	"\x13verification_key_id\x18\x02 \x01(\tR\x11verificationKeyId\x12\x1d\n" +
	"\n" +
	"proof_data\x18\x03 \x01(\fR\tproofData\"\x8d\x01\n" +
	"\x0fIssuerSignature\x12/\n" +
	"\x13signature_algorithm\x18\x01 \x01(\tR\x12signatureAlgorithm\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\fR\tsignature\x12+\n" +
	"\x11certificate_chain\x18\x03 \x03(\fR\x10certificateChain\",\n" +
	"\tDohAnchor\x12\x1f\n" +
	"\vdomain_name\x18\x01 \x01(\tR\n" +
	"domainName\"'\n" +
	"\n" +
	"GistAnchor\x12\x19\n" +
	"\bgist_url\x18\x01 \x01(\tR\agistUrl*8\n" +
	"\vTrustMethod\x12\x16\n" +
	"\x12METHOD_UNSPECIFIED\x10\x00\x12\a\n" +
	"\x03DOH\x10\x01\x12\b\n" +
	"\x04GIST\x10\x02*H\n" +
	"\vProofSystem\x12\x16\n" +
	"\x12SYSTEM_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aGROTH16\x10\x01\x12\t\n" +
	"\x05PLONK\x10\x02\x12\t\n" +
	"\x05STARK\x10\x03B*Z(github.com/Stygian-Inc/ptx-jesuit-go/ptxb\x06proto3"

var (
	file_ptx_proto_rawDescOnce sync.Once
	file_ptx_proto_rawDescData []byte
)

func file_ptx_proto_rawDescGZIP() []byte {
	file_ptx_proto_rawDescOnce.Do(func() {
		file_ptx_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ptx_proto_rawDesc), len(file_ptx_proto_rawDesc)))
	})
	return file_ptx_proto_rawDescData
}

var file_ptx_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_ptx_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_ptx_proto_goTypes = []any{
	(TrustMethod)(0),        // 0: ptx.v1.TrustMethod
	(ProofSystem)(0),        // 1: ptx.v1.ProofSystem
	(*PtxFile)(nil),         // 2: ptx.v1.PtxFile
	(*ZkProof)(nil),         // 3: ptx.v1.ZkProof
	(*IssuerSignature)(nil), // 4: ptx.v1.IssuerSignature
	(*DohAnchor)(nil),       // 5: ptx.v1.DohAnchor
	(*GistAnchor)(nil),      // 6: ptx.v1.GistAnchor
}
var file_ptx_proto_depIdxs = []int32{
	0, // 0: ptx.v1.PtxFile.trust_method:type_name -> ptx.v1.TrustMethod
	3, // 1: ptx.v1.PtxFile.proof:type_name -> ptx.v1.ZkProof
	5, // 2: ptx.v1.PtxFile.doh_details:type_name -> ptx.v1.DohAnchor
	6, // 3: ptx.v1.PtxFile.gist_details:type_name -> ptx.v1.GistAnchor
	4, // 4: ptx.v1.PtxFile.issuer_signature:type_name -> ptx.v1.IssuerSignature
	1, // 5: ptx.v1.ZkProof.proof_system:type_name -> ptx.v1.ProofSystem
	6, // [6:6] is the sub-list for method output_type
	6, // [6:6] is the sub-list for method input_type
	6, // [6:6] is the sub-list for extension type_name
	6, // [6:6] is the sub-list for extension extendee
	0, // [0:6] is the sub-list for field type_name
}

func init() { file_ptx_proto_init() }
func file_ptx_proto_init() {
	if File_ptx_proto != nil {
		return
	}
	file_ptx_proto_msgTypes[0].OneofWrappers = []any{
		(*PtxFile_DohDetails)(nil),
		(*PtxFile_GistDetails)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ptx_proto_rawDesc), len(file_ptx_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_ptx_proto_goTypes,
		DependencyIndexes: file_ptx_proto_depIdxs,
		EnumInfos:         file_ptx_proto_enumTypes,
		MessageInfos:      file_ptx_proto_msgTypes,
	}.Build()
	File_ptx_proto = out.File
	file_ptx_proto_goTypes = nil
	file_ptx_proto_depIdxs = nil
}
